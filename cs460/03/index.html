<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>A3 – Final (Flicker + Wireframe)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body{height:100%;margin:0;background:#000;color:#fff;font:16px system-ui,Arial}
    body{display:flex;flex-direction:column}
    header{position:sticky;top:0;z-index:5;text-align:center;padding:12px 0 8px;background:linear-gradient(#000,#000c 60%,#0000)}
    h1{margin:0 0 6px}
    .hint{max-width:1100px;margin:0 auto;padding:0 12px;line-height:1.3;text-shadow:0 1px 2px #000}
    kbd{padding:2px 6px;border:1px solid #888;border-bottom-width:2px;border-radius:4px;background:#111}
    #app{flex:1 1 auto;position:relative;min-height:360px}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
    .hud{position:fixed;left:10px;bottom:10px;background:#111b;border:1px solid #333;border-radius:8px;padding:8px 10px;font-size:13px;z-index:6}
    .err{position:fixed;right:10px;bottom:10px;background:#411;border:1px solid #833;border-radius:8px;padding:8px 10px;font-size:13px;z-index:6;display:none}
  </style>
</head>
<body>
  <header>
    <h1>A3 – Final (Flicker + Wireframe)</h1>
    <div class="hint">
      <strong>Place/scale:</strong> hold <kbd>Shift</kbd> then click-drag up/down to scale (color flips by sign).
      <strong>Keys:</strong> <kbd>F</kbd> flicker, <kbd>W</kbd> wireframe, <kbd>P</kbd> pattern on/off (green/pink),
      <kbd>1</kbd>/<kbd>2</kbd>/<kbd>3</kbd> cube/sphere/torus, <kbd>0</kbd> center camera, <kbd>R</kbd> reset, <kbd>S</kbd> save PNG.
      <br><small>(Tip: Shift + single click also drops a shape.)</small>
    </div>
  </header>

  <div id="app"></div>
  <div class="hud" id="hud">loading…</div>
  <div class="err" id="err"></div>

  <!-- Three.js r150.1 (reliable, no modules needed) -->
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>

  <script>
  (function(){
    const root = document.getElementById('app');
    const hud  = document.getElementById('hud');
    const err  = document.getElementById('err');
    if(!window.THREE){ err.textContent='three.js failed to load'; err.style.display='block'; return; }
    const THREE = window.THREE;

    const PINK  = '#ff2fb3';
    const GREEN = '#00ff66';

    // ---------- Scene ----------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true});
    renderer.outputEncoding = THREE.sRGBEncoding; // r150 sRGB fix
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    root.appendChild(renderer.domElement);

    function resize(){
      const w=root.clientWidth, h=root.clientHeight||1;
      camera.aspect=w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h,false);
    }
    resize(); window.addEventListener('resize', resize);

    // ---------- Simple built-in orbit control (no CDN dep) ----------
    class SimpleOrbit{
      constructor(camera, dom){
        this.camera=camera; this.dom=dom;
        this.target = new THREE.Vector3(0,0,0);
        this.sph = new THREE.Spherical(9, Math.PI/2, 0); // r, phi, theta
        this.drag=false; this.lastX=0; this.lastY=0;
        dom.addEventListener('mousedown', e=>{ if(e.shiftKey) return; this.drag=true; this.lastX=e.clientX; this.lastY=e.clientY; });
        window.addEventListener('mousemove', e=>{
          if(!this.drag) return;
          const dx=e.clientX-this.lastX, dy=e.clientY-this.lastY; this.lastX=e.clientX; this.lastY=e.clientY;
          this.sph.theta -= dx*0.005;
          this.sph.phi   = Math.min(Math.PI-0.05, Math.max(0.05, this.sph.phi + dy*0.005));
          this.update();
        });
        window.addEventListener('mouseup', ()=>{ this.drag=false; });
        dom.addEventListener('wheel', e=>{
          const s=Math.exp(e.deltaY*0.001);
          this.sph.radius = Math.min(50, Math.max(2, this.sph.radius*s));
          this.update();
        }, {passive:true});
        this.update();
      }
      update(){
        const p=new THREE.Vector3().setFromSpherical(this.sph).add(this.target);
        this.camera.position.copy(p);
        this.camera.lookAt(this.target);
      }
      center(){ this.sph.radius=9; this.sph.theta=0; this.sph.phi=Math.PI/2; this.update(); }
    }
    const controls = new SimpleOrbit(camera, renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, .65));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(5,8,6); scene.add(dir);

    // ---------- Checker (pink/green) ----------
    function makeChecker(size=256, squares=8, a=PINK, b=GREEN){
      const c=document.createElement('canvas'); c.width=c.height=size;
      const ctx=c.getContext('2d'); const cell=size/squares;
      for(let y=0;y<squares;y++) for(let x=0;x<squares;x++){
        ctx.fillStyle=((x+y)%2===0)?a:b; ctx.fillRect(x*cell,y*cell,cell,cell);
      }
      const tex=new THREE.CanvasTexture(c); tex.encoding=THREE.sRGBEncoding; tex.anisotropy=4; return tex;
    }
    const checker = makeChecker();

    // ---------- Materials / shapes ----------
    let WIREFRAME=false, FLICKER=false, USE_PATTERN=false;
    function mat(baseHex){
      const m=new THREE.MeshStandardMaterial({
        color: USE_PATTERN?0xffffff:baseHex, metalness:.2, roughness:.35,
        map: USE_PATTERN?checker:null
      });
      m.wireframe=WIREFRAME; return m;
    }

    let SHAPE_MODE='torus';
    function geom(){
      if(SHAPE_MODE==='cube')   return new THREE.BoxGeometry(1.4,1.4,1.4,2,2,2);
      if(SHAPE_MODE==='sphere') return new THREE.SphereGeometry(0.9,36,24);
      return new THREE.TorusKnotGeometry(0.8,0.22,160,24);
    }

    const meshes=[];
    function hudText(){
      hud.textContent = `shapes: ${meshes.length} • mode: ${SHAPE_MODE} • pattern: ${USE_PATTERN?'on':'off'} • wire: ${WIREFRAME?'on':'off'} • flicker: ${FLICKER?'on':'off'}`;
    }

    function addShape(pos, scale=1, sign=+1){
      const baseHex=(sign>=0)?new THREE.Color(PINK).getHex():new THREE.Color(GREEN).getHex();
      const m=new THREE.Mesh(geom(), mat(baseHex));
      m.userData.baseHex=baseHex;
      m.position.copy(pos);
      m.scale.setScalar(Math.max(.1, Math.abs(scale)));
      scene.add(m); meshes.push(m); hudText();
      return m;
    }

    // Default centered torus (fully visible)
    const defaultMesh = addShape(new THREE.Vector3(0,0,0), 1.4, +1);

    // ---------- Placement on z=0 with Shift ----------
    const plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
    const ray=new THREE.Raycaster(); const ndc=new THREE.Vector2();
    function toPlane(e){
      const r=renderer.domElement.getBoundingClientRect();
      ndc.x=((e.clientX-r.left)/r.width)*2-1;
      ndc.y=-((e.clientY-r.top)/r.height)*2+1;
      ray.setFromCamera(ndc,camera);
      const p=new THREE.Vector3(); return ray.ray.intersectPlane(plane,p)?p:null;
    }

    let placing=null;
    function down(e){
      if(!e.shiftKey) return;
      const p=toPlane(e)||new THREE.Vector3();
      placing={mesh:addShape(p,1,+1), startY:e.clientY};
      e.preventDefault();
    }
    function move(e){
      if(!placing) return;
      const dy=e.clientY-placing.startY;
      let s=1+(-dy/120);
      const sign=(s>=0)?+1:-1;
      const hex=(sign>=0)?new THREE.Color(PINK).getHex():new THREE.Color(GREEN).getHex();
      placing.mesh.userData.baseHex=hex;
      if(USE_PATTERN){ placing.mesh.material.color.set(0xffffff); placing.mesh.material.map=checker; }
      else{ placing.mesh.material.map=null; placing.mesh.material.color.setHex(hex); }
      placing.mesh.material.needsUpdate=true;
      placing.mesh.scale.setScalar(Math.max(.1, Math.abs(s)));
      const p=toPlane(e); if(p) placing.mesh.position.copy(p);
    }
    function up(){ placing=null; }
    const el=renderer.domElement;
    el.addEventListener('pointerdown', down);
    el.addEventListener('pointermove', move);
    window.addEventListener('pointerup', up);
    el.addEventListener('click',(e)=>{ if(!e.shiftKey||placing) return; const p=toPlane(e)||new THREE.Vector3(); addShape(p,1,+1); });

    // ---------- Keys ----------
    function applyWire(){ meshes.forEach(m=>m.material.wireframe=WIREFRAME); }
    function applyPattern(){
      meshes.forEach(m=>{
        if(USE_PATTERN){ m.material.color.set(0xffffff); m.material.map=checker; }
        else{ m.material.map=null; m.material.color.setHex(m.userData.baseHex||new THREE.Color(PINK).getHex()); }
        m.material.needsUpdate=true;
      });
    }
    window.addEventListener('keydown',(e)=>{
      const k=e.key.toLowerCase();
      if(k==='w'){ WIREFRAME=!WIREFRAME; applyWire(); hudText(); }
      else if(k==='f'){ FLICKER=!FLICKER; if(!FLICKER){ meshes.forEach(m=>m.material.emissiveIntensity=0); } hudText(); }
      else if(k==='p'){ USE_PATTERN=!USE_PATTERN; applyPattern(); hudText(); }
      else if(k==='1'){ SHAPE_MODE='cube';  hudText(); }
      else if(k==='2'){ SHAPE_MODE='sphere';hudText(); }
      else if(k==='3'){ SHAPE_MODE='torus'; hudText(); }
      else if(k==='0'){ controls.center(); }
      else if(k==='r'){ meshes.forEach(m=>scene.remove(m)); meshes.length=0; addShape(new THREE.Vector3(0,0,0),1.4,+1); controls.center(); hudText(); }
      else if(k==='s'){ const a=document.createElement('a'); a.download='a3.png'; a.href=renderer.domElement.toDataURL('image/png'); a.click(); }
    });

    // ---------- Animate ----------
    const clock=new THREE.Clock();
    (function tick(){
      requestAnimationFrame(tick);
      const t=clock.getElapsedTime();
      if(defaultMesh){ defaultMesh.rotation.y=t*.35; defaultMesh.rotation.x=t*.15; }
      if(FLICKER){
        const pulse=.4+.6*Math.max(0,Math.sin(t*6));
        meshes.forEach(m=>{ m.material.emissive=new THREE.Color(0xffffff); m.material.emissiveIntensity=pulse; });
      }
      renderer.render(scene,camera);
    })();

    hudText();
  })();
  </script>
</body>
</html>
