<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CS460 A5 — Three.js Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#0b1636;color:#cbd5e1;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    #ui{position:fixed;left:10px;bottom:10px;display:flex;gap:8px;align-items:center}
    select,button{background:#111827;color:#e5e7eb;border:1px solid #374151;border-radius:8px;padding:6px 10px}
    #hint{position:fixed;left:8px;top:8px;font-size:12px;opacity:.7}
    canvas{display:block;width:100vw;height:100vh}
  </style>

  <!-- Import map so our local modules resolve -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three.module.js",
      "three/addons/": "./"
    }
  }
  </script>
</head>
<body>
  <div id="hint">drag to orbit · ⌘/Ctrl+wheel to zoom</div>
  <canvas id="c"></canvas>
  <div id="ui">
    <label>Model:</label>
    <select id="model">
      <option value="Shoe.glb" selected>Shoe.glb (Blender)</option>
      <option value="poly.glb">poly.glb (Polycam)</option>
    </select>
    <button id="reset">Reset View</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/OrbitControls.js';
    import { GLTFLoader }  from 'three/addons/GLTFLoader.js';

    // renderer
    const canvas   = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x0b1636, 1);

    // scene + camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 1000);
    camera.position.set(0.6, 0.35, 0.8);

    // controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(1,2,1);
    scene.add(dir);

    // ground (soft)
    const ground = new THREE.Mesh(
      new THREE.CircleGeometry(1.2, 64),
      new THREE.MeshPhongMaterial({ color:0x0b0f1f, shininess:10 })
    );
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.001;
    scene.add(ground);

    // helpers
    const loader = new GLTFLoader();
    let current = null;

    function frameObject(obj){
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3()).length() || 1;
      const center = box.getCenter(new THREE.Vector3());

      controls.target.copy(center);
      const dist = size * 1.6;
      const dirVec = new THREE.Vector3(1, 0.6, 1).normalize();
      camera.position.copy(center).add(dirVec.multiplyScalar(dist));
      camera.near = size/200;
      camera.far  = size*20;
      camera.updateProjectionMatrix();
      controls.update();
    }

    function clearCurrent(){
      if (!current) return;
      scene.remove(current);
      current.traverse?.(o=>{
        if (o.geometry) o.geometry.dispose?.();
        if (o.material){
          const mats = Array.isArray(o.material) ? o.material : [o.material];
          mats.forEach(m=>{ m.map?.dispose?.(); m.dispose?.(); });
        }
      });
      current = null;
    }

    function loadModel(url){
      clearCurrent();
      loader.load(url, (gltf)=>{
        current = gltf.scene || gltf.scenes?.[0];
        current.traverse(o=>{
          if (o.isMesh){
            o.castShadow = o.receiveShadow = true;
            if (o.material) o.material.side = THREE.FrontSide;
          }
        });
        scene.add(current);
        frameObject(current);
      }, undefined, (err)=>{
        console.error('GLB load error:', err);
        alert('Could not load '+url+' — check the filename/path in /05/');
      });
    }

    // UI
    const select = document.getElementById('model');
    const reset  = document.getElementById('reset');
    select.addEventListener('change', ()=> loadModel(select.value));
    reset.addEventListener('click', ()=> current && frameObject(current));

    // first load
    loadModel(select.value);

    // resize
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // loop
    renderer.setAnimationLoop(()=>{
      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
</html>
