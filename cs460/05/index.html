<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>CS460 A5 — Viewer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{margin:0;height:100%;background:#0c1740;color:#eee;font:14px/1.2 system-ui,Segoe UI,Roboto}
  canvas{display:block;position:fixed;inset:0}
  .hint{position:fixed;top:6px;left:6px;opacity:.8}
</style>
<!-- stats.js (global) -->
<script src="https://mrdoob.github.io/stats.js/build/stats.min.js"></script>
</head>
<body>
<div class="hint">drag to orbit · ⌘/Ctrl+wheel to zoom</div>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from './three.module.js';
import {OrbitControls} from './OrbitControls.js';
import {GLTFLoader} from './GLTFLoader.js';
import {Pane} from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';
import {AnaglyphEffect} from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/effects/AnaglyphEffect.js';
import {VertexNormalsHelper} from 'https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/helpers/VertexNormalsHelper.js';

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 10000);
camera.position.set(0,1.5,6);
const controls = new OrbitControls(camera, renderer.domElement);

const dirLight = new THREE.DirectionalLight(0xffffff, 2);
dirLight.position.set(2,3,4);
scene.add(dirLight);

const ambLight = new THREE.AmbientLight(0x404040, 1.2);
scene.add(ambLight);

// ground-ish faint env (optional)
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new THREE.Scene()).texture;

// globals for UI/animate
window.SCENE = {
  anaglyph:false,
  poly:null,
  blender:null,
  blender_helper:null,
  rotate_poly:false,
  rotate_blender:false,
  do_rotate_poly(){ this.rotate_poly = !this.rotate_poly; },
  do_rotate_blender(){ this.rotate_blender = !this.rotate_blender; },
  blender_old_material:null,
  change_material(){
    if(!this.blender) return;
    if(!this.blender_old_material){
      this.blender_old_material = this.blender.material.clone();
      this.blender.material = new THREE.MeshNormalMaterial();
    }else{
      this.blender.material = this.blender_old_material.clone();
      this.blender_old_material = null;
    }
  }
};

// anaglyph effect
const effect = new AnaglyphEffect(renderer);

// loaders
const loader = new GLTFLoader();
function identQ(o){ o.quaternion.set(0,0,0,1); }

function fitCameraToObject(obj){
  const bs = new THREE.Box3().setFromObject(obj);
  const size = bs.getSize(new THREE.Vector3()).length();
  const center = bs.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  const dist = size/ (2*Math.tan(THREE.MathUtils.degToRad(camera.fov/2)));
  camera.position.copy(center).add(new THREE.Vector3(dist, dist*0.3, dist));
  camera.near = size/100; camera.far = size*100; camera.updateProjectionMatrix();
}

let polyMesh, blenderMesh;

// Load PolyCam original
loader.load('poly.glb', (gltf)=>{
  const m = gltf.scene.children[0];
  m.scale.set(10,10,10);
  identQ(m);
  m.position.x = -3;
  scene.add(m);
  polyMesh = m;
  window.SCENE.poly = m;
  fitCameraToObject(m);
});

// Load cleaned Blender edit
loader.load('Shoe.glb', (gltf)=>{
  const m = gltf.scene.children[0];
  m.scale.set(10,10,10);
  identQ(m);
  m.position.x = 3;
  scene.add(m);
  blenderMesh = m;
  window.SCENE.blender = m;

  // normals helper (hidden by default, toggled in UI)
  const helper = new VertexNormalsHelper(m, 0.05, 0x0080ff);
  helper.visible = false;
  scene.add(helper);
  window.SCENE.blender_helper = helper;
});

// --- TWEAKPANE UI ----------------------------------------------------------
const pane = new Pane();
const sceneUI = pane.addFolder({title:'Scene'});
sceneUI.addBinding(window.SCENE,'anaglyph',{label:'Anaglyph'});
sceneUI.addBinding(dirLight.position,'x',{min:-100,max:100,label:'Light X'});
sceneUI.addBinding(dirLight.position,'y',{min:-100,max:100,label:'Light Y'});
sceneUI.addBinding(dirLight.position,'z',{min:-100,max:100,label:'Light Z'});
sceneUI.addBinding(dirLight,'intensity',{min:0,max:5,step:.1,label:'Dir Intensity'});
const amb = {color:'#666666', intensity:ambLight.intensity};
sceneUI.addBinding(amb,'color',{label:'Ambient'}).on('change',ev=>{
  ambLight.color.set(ev.value);
});
sceneUI.addBinding(amb,'intensity',{min:0,max:5,step:.1,label:'Amb Intensity'}).on('change',ev=>{
  ambLight.intensity = ev.value;
});

const polyUI = pane.addFolder({title:'PolyCam Mesh'});
polyUI.addButton({title:'rotate!'}).on('click', ()=>window.SCENE.do_rotate_poly());
polyUI.addButton({title:'wireframe toggle'}).on('click', ()=>{
  if(window.SCENE.poly && window.SCENE.poly.material) {
    window.SCENE.poly.material.wireframe = !window.SCENE.poly.material.wireframe;
    window.SCENE.poly.material.needsUpdate = true;
  }
});

const blenderUI = pane.addFolder({title:'Blender Mesh'});
blenderUI.addButton({title:'rotate!'}).on('click', ()=>window.SCENE.do_rotate_blender());
blenderUI.addBinding({show:false},'show',{label:'Show normals!'}).on('change',ev=>{
  if(window.SCENE.blender_helper) window.SCENE.blender_helper.visible = ev.value;
});
blenderUI.addButton({title:'Change Material!'}).on('click', ()=>window.SCENE.change_material());

// stats
const stats = new Stats(); document.body.appendChild(stats.dom);

// animate
const qIdent = new THREE.Quaternion(0,0,0,1);
const q180 = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), Math.PI);

function animate(){
  requestAnimationFrame(animate);

  if(window.SCENE.poly){
    window.SCENE.poly.quaternion.slerp( window.SCENE.rotate_poly ? q180 : qIdent, 0.02 );
  }
  if(window.SCENE.blender){
    window.SCENE.blender.quaternion.slerp( window.SCENE.rotate_blender ? q180 : qIdent, 0.02 );
    if(window.SCENE.blender_helper && window.SCENE.blender_helper.visible){
      window.SCENE.blender_helper.update();
    }
  }

  controls.update();
  stats.update();
  if(window.SCENE.anaglyph) effect.render(scene,camera);
  else renderer.render(scene,camera);
}
animate();

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  effect.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
